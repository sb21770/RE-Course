<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: x86/x64 Architecture</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700;900&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #131a2b;
            --bg-card: #1a2235;
            --accent-primary: #00ff88;
            --accent-secondary: #00b4d8;
            --accent-warning: #ff6b35;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --border-color: #2a3548;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: var(--bg-primary); color: var(--text-primary); line-height: 1.9; }
        .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
        nav { background: var(--bg-secondary); padding: 1rem 2rem; border-bottom: 1px solid var(--border-color); position: sticky; top: 0; z-index: 100; }
        nav a { color: var(--accent-primary); text-decoration: none; }
        nav a:hover { text-decoration: underline; }
        .chapter-header { background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%); padding: 4rem 2rem; text-align: center; border-bottom: 1px solid var(--border-color); }
        .chapter-number { display: inline-block; background: linear-gradient(135deg, #00ff88 0%, #00b4d8 100%); color: var(--bg-primary); padding: 0.5rem 1.5rem; border-radius: 30px; font-weight: 700; margin-bottom: 1rem; }
        h1 { font-size: 2.5rem; margin-bottom: 1rem; background: linear-gradient(135deg, #00ff88 0%, #00b4d8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-secondary); font-size: 1.1rem; }
        .content { padding: 3rem 0; }
        h2 { font-size: 1.8rem; color: var(--accent-primary); margin: 3rem 0 1.5rem; padding-bottom: 0.5rem; border-bottom: 2px solid var(--border-color); }
        h3 { font-size: 1.3rem; color: var(--accent-secondary); margin: 2rem 0 1rem; }
        p { margin-bottom: 1.5rem; }
        .definition { background: var(--bg-card); border-left: 4px solid var(--accent-primary); padding: 1.5rem; border-radius: 0 10px 10px 0; margin: 1.5rem 0; }
        .definition-title { color: var(--accent-primary); font-weight: 700; font-size: 1.1rem; margin-bottom: 0.5rem; }
        .info-box { background: rgba(0, 180, 216, 0.1); border: 1px solid var(--accent-secondary); border-radius: 10px; padding: 1.5rem; margin: 1.5rem 0; }
        .info-box-title { color: var(--accent-secondary); font-weight: 700; margin-bottom: 0.5rem; }
        .warning-box { background: rgba(255, 107, 53, 0.1); border: 1px solid var(--accent-warning); border-radius: 10px; padding: 1.5rem; margin: 1.5rem 0; }
        .warning-box-title { color: var(--accent-warning); font-weight: 700; margin-bottom: 0.5rem; }
        ul, ol { margin: 1rem 0 1.5rem 1.5rem; }
        li { margin-bottom: 0.8rem; }
        code { font-family: 'Fira Code', monospace; background: var(--bg-card); padding: 0.2rem 0.5rem; border-radius: 4px; color: var(--accent-primary); font-size: 0.9rem; }
        pre { font-family: 'Fira Code', monospace; background: var(--bg-card); padding: 1.5rem; border-radius: 10px; overflow-x: auto; margin: 1.5rem 0; border: 1px solid var(--border-color); }
        .diagram { background: var(--bg-card); border-radius: 15px; padding: 2rem; margin: 2rem 0; text-align: center; border: 1px solid var(--border-color); }
        table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; background: var(--bg-card); border-radius: 10px; overflow: hidden; }
        th, td { padding: 1rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        th { background: var(--bg-secondary); color: var(--accent-primary); font-weight: 600; }
        tr:last-child td { border-bottom: none; }
        tr:hover { background: rgba(0, 255, 136, 0.05); }
        .nav-buttons { display: flex; justify-content: space-between; margin-top: 4rem; padding-top: 2rem; border-top: 1px solid var(--border-color); }
        .nav-btn { background: var(--bg-card); color: var(--text-primary); padding: 1rem 2rem; border-radius: 10px; text-decoration: none; border: 1px solid var(--border-color); transition: all 0.3s; }
        .nav-btn:hover { border-color: var(--accent-primary); transform: translateY(-3px); }
    </style>
</head>
<body>
    <nav>
        <a href="index.html">‚Üê Back to Main Menu</a>
    </nav>

    <header class="chapter-header">
        <div class="chapter-number">Chapter 3</div>
        <h1>x86/x64 Architecture</h1>
        <p class="subtitle">Understanding the CPU, registers, and how code executes</p>
    </header>

    <div class="container">
        <div class="content">
            
            <h2>üñ•Ô∏è What is CPU Architecture?</h2>

            <div class="definition">
                <div class="definition-title">üìñ Definition: CPU Architecture</div>
                <p>The fundamental design of the processor - what instructions it understands, how much memory it can handle, and how it's organized internally.</p>
            </div>

            <div class="definition">
                <div class="definition-title">üìñ Definition: x86</div>
                <p>A family of architectures from Intel and AMD. The name comes from processors 8086, 80286, 80386...<br>
                <strong>x86</strong> = 32-bit | <strong>x64</strong> (or x86-64, AMD64) = 64-bit</p>
            </div>

            <p>
                Almost all desktop computers and most servers use x86/x64.
                This is the architecture you'll encounter most often when doing RE on Windows software.
            </p>

            <h2>üì¶ Registers - The CPU's "Variables"</h2>

            <div class="definition">
                <div class="definition-title">üìñ Definition: Register</div>
                <p>A small, extremely fast storage area inside the CPU itself. Used to store temporary data during calculations. Much faster than RAM.</p>
            </div>

            <h3>General Purpose Registers</h3>

            <p>In 32-bit, there are 8 general purpose registers, each 32 bits (4 bytes) in size:</p>

            <table>
                <tr>
                    <th>Name</th>
                    <th>Full Name</th>
                    <th>Common Use</th>
                </tr>
                <tr>
                    <td><code>EAX</code></td>
                    <td>Extended Accumulator</td>
                    <td>Function return values, calculations</td>
                </tr>
                <tr>
                    <td><code>EBX</code></td>
                    <td>Extended Base</td>
                    <td>Data pointer, general use</td>
                </tr>
                <tr>
                    <td><code>ECX</code></td>
                    <td>Extended Counter</td>
                    <td>Loop counter, iterations</td>
                </tr>
                <tr>
                    <td><code>EDX</code></td>
                    <td>Extended Data</td>
                    <td>Extension for EAX, I/O operations</td>
                </tr>
                <tr>
                    <td><code>ESI</code></td>
                    <td>Extended Source Index</td>
                    <td>Source pointer in copy operations</td>
                </tr>
                <tr>
                    <td><code>EDI</code></td>
                    <td>Extended Destination Index</td>
                    <td>Destination pointer in copy operations</td>
                </tr>
                <tr>
                    <td><code>EBP</code></td>
                    <td>Extended Base Pointer</td>
                    <td>Points to base of Stack Frame</td>
                </tr>
                <tr>
                    <td><code>ESP</code></td>
                    <td>Extended Stack Pointer</td>
                    <td>Points to top of Stack</td>
                </tr>
            </table>

            <h3>Register Subdivision - 32/16/8 bit</h3>

            <p>
                Each 32-bit register is divided into smaller parts that can be accessed separately:
            </p>

            <div class="diagram">
                <svg viewBox="0 0 500 120" xmlns="http://www.w3.org/2000/svg">
                    <!-- 32-bit register -->
                    <rect x="50" y="20" width="400" height="40" rx="5" fill="#1a2235" stroke="#00ff88" stroke-width="2"/>
                    <text x="250" y="45" text-anchor="middle" fill="#00ff88" font-size="14" font-family="Fira Code">EAX (32 bits)</text>
                    
                    <!-- 16-bit part -->
                    <rect x="250" y="70" width="200" height="35" rx="5" fill="#1a2235" stroke="#00b4d8" stroke-width="2"/>
                    <text x="350" y="92" text-anchor="middle" fill="#00b4d8" font-size="12" font-family="Fira Code">AX (16 bits)</text>
                    
                    <!-- 8-bit parts -->
                    <rect x="250" y="70" width="100" height="35" rx="5" fill="none" stroke="#ff6b35" stroke-width="2"/>
                    <text x="300" y="92" text-anchor="middle" fill="#ff6b35" font-size="12" font-family="Fira Code">AH</text>
                    
                    <rect x="350" y="70" width="100" height="35" rx="5" fill="none" stroke="#ff6b35" stroke-width="2"/>
                    <text x="400" y="92" text-anchor="middle" fill="#ff6b35" font-size="12" font-family="Fira Code">AL</text>
                    
                    <!-- Labels -->
                    <text x="300" y="115" text-anchor="middle" fill="#a0a0a0" font-size="10">8 bits</text>
                    <text x="400" y="115" text-anchor="middle" fill="#a0a0a0" font-size="10">8 bits</text>
                </svg>
            </div>

            <table>
                <tr>
                    <th>Size</th>
                    <th>EAX</th>
                    <th>EBX</th>
                    <th>ECX</th>
                    <th>EDX</th>
                </tr>
                <tr>
                    <td>32-bit</td>
                    <td><code>EAX</code></td>
                    <td><code>EBX</code></td>
                    <td><code>ECX</code></td>
                    <td><code>EDX</code></td>
                </tr>
                <tr>
                    <td>16-bit</td>
                    <td><code>AX</code></td>
                    <td><code>BX</code></td>
                    <td><code>CX</code></td>
                    <td><code>DX</code></td>
                </tr>
                <tr>
                    <td>8-bit high</td>
                    <td><code>AH</code></td>
                    <td><code>BH</code></td>
                    <td><code>CH</code></td>
                    <td><code>DH</code></td>
                </tr>
                <tr>
                    <td>8-bit low</td>
                    <td><code>AL</code></td>
                    <td><code>BL</code></td>
                    <td><code>CL</code></td>
                    <td><code>DL</code></td>
                </tr>
            </table>

            <h3>In 64-bit (x64)</h3>

            <p>Registers were extended to 64 bits and 8 new ones were added:</p>

            <ul>
                <li><code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code> - extended versions of existing</li>
                <li><code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code> - extended versions of existing</li>
                <li><code>R8</code>-<code>R15</code> - 8 new registers!</li>
            </ul>

            <div class="info-box">
                <div class="info-box-title">üí° How to identify 32 vs 64 bit</div>
                <pre style="background: transparent; padding: 0; border: none; margin: 0;">
32-bit: E prefix  --> EAX, EBX, ECX, EDX...
64-bit: R prefix  --> RAX, RBX, RCX, RDX...
16-bit: no prefix --> AX, BX, CX, DX...
                </pre>
            </div>

            <h2>üö© FLAGS Register</h2>

            <div class="definition">
                <div class="definition-title">üìñ Definition: FLAGS Register</div>
                <p>A special register where each bit represents a status ("flag"). Flags change automatically after operations and are used for decisions (conditions, jumps).</p>
            </div>

            <p>The most important flags:</p>

            <table>
                <tr>
                    <th>Flag</th>
                    <th>Name</th>
                    <th>When set (=1)</th>
                </tr>
                <tr>
                    <td><code>ZF</code></td>
                    <td>Zero Flag</td>
                    <td>Result is 0</td>
                </tr>
                <tr>
                    <td><code>SF</code></td>
                    <td>Sign Flag</td>
                    <td>Result is negative (top bit = 1)</td>
                </tr>
                <tr>
                    <td><code>CF</code></td>
                    <td>Carry Flag</td>
                    <td>Overflow in unsigned operation</td>
                </tr>
                <tr>
                    <td><code>OF</code></td>
                    <td>Overflow Flag</td>
                    <td>Overflow in signed operation</td>
                </tr>
            </table>

            <div class="info-box">
                <div class="info-box-title">üí° Example: Using Flags</div>
                <pre style="background: transparent; padding: 0; border: none; margin: 0;">
CMP EAX, EBX    ; Compare EAX to EBX (subtract without saving)
JE  somewhere   ; Jump if Equal - jumps if ZF=1 (they are equal)
                </pre>
            </div>

            <h2>üìç Instruction Pointer</h2>

            <div class="definition">
                <div class="definition-title">üìñ Definition: EIP / RIP</div>
                <p><strong>Extended Instruction Pointer</strong> (32-bit) or <strong>RIP</strong> (64-bit).<br>
                A register that contains the address of the next instruction to be executed. Cannot be modified directly!</p>
            </div>

            <p>
                The CPU always looks at EIP/RIP to know where to read the next instruction from.
                After each instruction, EIP advances automatically.
            </p>

            <h2>‚öôÔ∏è Instruction Cycle (Fetch-Decode-Execute)</h2>

            <p>This is how the CPU executes each instruction:</p>

            <div class="diagram">
                <svg viewBox="0 0 500 150" xmlns="http://www.w3.org/2000/svg">
                    <!-- Step 1: Fetch -->
                    <rect x="30" y="50" width="120" height="60" rx="10" fill="#1a2235" stroke="#00ff88" stroke-width="2"/>
                    <text x="90" y="75" text-anchor="middle" fill="#00ff88" font-size="14" font-weight="bold">Fetch</text>
                    <text x="90" y="95" text-anchor="middle" fill="#a0a0a0" font-size="10">Read instruction</text>
                    <text x="90" y="35" text-anchor="middle" fill="#00ff88" font-size="12">1</text>
                    
                    <!-- Arrow -->
                    <path d="M155 80 L175 80" stroke="#00b4d8" stroke-width="2" marker-end="url(#arr1)"/>
                    
                    <!-- Step 2: Decode -->
                    <rect x="180" y="50" width="120" height="60" rx="10" fill="#1a2235" stroke="#00b4d8" stroke-width="2"/>
                    <text x="240" y="75" text-anchor="middle" fill="#00b4d8" font-size="14" font-weight="bold">Decode</text>
                    <text x="240" y="95" text-anchor="middle" fill="#a0a0a0" font-size="10">Parse instruction</text>
                    <text x="240" y="35" text-anchor="middle" fill="#00b4d8" font-size="12">2</text>
                    
                    <!-- Arrow -->
                    <path d="M305 80 L325 80" stroke="#ff6b35" stroke-width="2" marker-end="url(#arr2)"/>
                    
                    <!-- Step 3: Execute -->
                    <rect x="330" y="50" width="120" height="60" rx="10" fill="#1a2235" stroke="#ff6b35" stroke-width="2"/>
                    <text x="390" y="75" text-anchor="middle" fill="#ff6b35" font-size="14" font-weight="bold">Execute</text>
                    <text x="390" y="95" text-anchor="middle" fill="#a0a0a0" font-size="10">Perform action</text>
                    <text x="390" y="35" text-anchor="middle" fill="#ff6b35" font-size="12">3</text>
                    
                    <!-- Loop arrow -->
                    <path d="M450 80 Q 480 80 480 130 Q 480 140 250 140 Q 20 140 20 80 Q 20 70 30 70" 
                          stroke="#a0a0a0" stroke-width="1" fill="none" stroke-dasharray="5,5" marker-end="url(#arr3)"/>
                    <text x="250" y="135" text-anchor="middle" fill="#a0a0a0" font-size="10">Repeat</text>
                    
                    <defs>
                        <marker id="arr1" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L9,3 z" fill="#00b4d8"/>
                        </marker>
                        <marker id="arr2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L9,3 z" fill="#ff6b35"/>
                        </marker>
                        <marker id="arr3" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L9,3 z" fill="#a0a0a0"/>
                        </marker>
                    </defs>
                </svg>
            </div>

            <ol>
                <li><strong>Fetch:</strong> Read the instruction from the address EIP points to</li>
                <li><strong>Decode:</strong> Parse what the instruction is and its parameters</li>
                <li><strong>Execute:</strong> Perform the operation and update registers/memory</li>
            </ol>

            <h2>üìä Endianness - Byte Order</h2>

            <div class="definition">
                <div class="definition-title">üìñ Definition: Endianness</div>
                <p>The order in which bytes are stored in memory.<br>
                <strong>Little Endian:</strong> The low byte is stored first at the lowest address (x86/x64 uses this!)<br>
                <strong>Big Endian:</strong> The high byte is stored first</p>
            </div>

            <h3>What Does This Mean in Practice?</h3>
            
            <p>
                When we have a number that takes more than one byte (e.g., 4 bytes), the CPU needs to decide in what order to store it in memory.
                In Little Endian, the "little" (low) part of the number is stored first.
            </p>

            <div class="info-box">
                <div class="info-box-title">üí° Example: Little Endian</div>
                <p>Let's say we have the value <code>0x12345678</code> (a 4-byte number) and we want to store it at address <code>0x100</code>:</p>
                
                <p style="margin: 1rem 0;"><strong>Breaking the number into 4 bytes:</strong></p>
                <pre style="background: transparent; padding: 0; border: none; margin: 0;">
0x12345678
  ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ
  ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îî‚îÄ‚îÄ 0x78 (Least Significant Byte - LSB)
  ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îî‚îÄ‚îÄ‚îÄ‚îÄ 0x56
  ‚îÇ‚îÇ‚îî‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 0x34
  ‚îî‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 0x12 (Most Significant Byte - MSB)
                </pre>

                <p style="margin: 1rem 0;"><strong>How it looks in memory (Little Endian):</strong></p>
                <pre style="background: transparent; padding: 0; border: none; margin: 0;">
Address: 0x100  0x101  0x102  0x103
Value:   0x78   0x56   0x34   0x12
         ‚Üë
         LSB is stored at the lowest address!
                </pre>
                
                <p style="margin-bottom: 0; margin-top: 1rem;">
                    <strong>Note:</strong> Addresses 0x100-0x103 are just 4 consecutive memory cells - each cell holds one byte.
                </p>
            </div>

            <h3>üîß Why Does This Matter in RE?</h3>
            
            <p>
                When you look at memory in a debugger, you see the order that's <strong>stored in memory</strong>.
                But to understand the <strong>actual value</strong> that the CPU sees, you need to reverse the byte order!
            </p>

            <div class="info-box">
                <div class="info-box-title">üí° Practical Example</div>
                <p>You see this memory in the debugger:</p>
                <pre style="background: transparent; padding: 0; border: none; margin: 0;">
0x401000: 78 56 34 12 48 65 6C 6C 6F 00
                </pre>
                
                <table style="margin: 1rem 0; font-size: 0.9rem;">
                    <tr>
                        <th>Bytes</th>
                        <th>Type</th>
                        <th>What you see</th>
                        <th>Actual value</th>
                    </tr>
                    <tr>
                        <td><code>78 56 34 12</code></td>
                        <td>4-byte integer</td>
                        <td>78563412</td>
                        <td><strong>0x12345678</strong> (reverse!)</td>
                    </tr>
                    <tr>
                        <td><code>48 65 6C 6C 6F 00</code></td>
                        <td>String</td>
                        <td>-</td>
                        <td><strong>"Hello"</strong> (don't reverse!)</td>
                    </tr>
                </table>
            </div>

            <h3>üìã When to Reverse and When Not To?</h3>
            
            <table>
                <tr>
                    <th>Data Type</th>
                    <th>Reverse?</th>
                    <th>Explanation</th>
                </tr>
                <tr>
                    <td>Pointers / Addresses</td>
                    <td>‚úÖ Yes</td>
                    <td>4/8 byte number</td>
                </tr>
                <tr>
                    <td>Integers</td>
                    <td>‚úÖ Yes</td>
                    <td>2/4/8 byte number</td>
                </tr>
                <tr>
                    <td>Strings</td>
                    <td>‚ùå No</td>
                    <td>Each char is 1 byte - read left to right</td>
                </tr>
                <tr>
                    <td>Single byte</td>
                    <td>‚ùå No</td>
                    <td>Nothing to reverse</td>
                </tr>
                <tr>
                    <td>Byte array</td>
                    <td>‚ùå No</td>
                    <td>Read as you see it</td>
                </tr>
            </table>

            <h3>üîç How to Identify the Data Type?</h3>
            
            <p>Good question! Everything looks like hex. Here are the main ways:</p>

            <p><strong>1. The instruction tells you the size:</strong></p>
            <pre>
mov eax, [0x401000]    ; EAX = 32-bit  ‚Üí  4 bytes  ‚Üí  reverse!
mov al, [0x401000]     ; AL = 8-bit    ‚Üí  1 byte   ‚Üí  don't reverse
mov rax, [0x401000]    ; RAX = 64-bit  ‚Üí  8 bytes  ‚Üí  reverse!
            </pre>

            <p><strong>2. The instruction type reveals it's an address:</strong></p>
            <pre>
call [0x401000]        ; CALL ‚Üí this is a function address
jmp [0x401000]         ; JMP ‚Üí this is a jump address
lea eax, [0x401000]    ; LEA = Load Address ‚Üí this is an address
            </pre>

            <p><strong>3. Identify Strings by pattern:</strong></p>
            <pre>
48 65 6C 6C 6F 00  ‚Üí  "Hello" + null terminator
‚îÇ                ‚îÇ
‚îÇ                ‚îî‚îÄ‚îÄ 00 at end = end of string
‚îî‚îÄ‚îÄ Values 0x20-0x7E = readable ASCII characters
            </pre>

            <p><strong>4. Identify Pointers by address range:</strong></p>
            <pre>
00 10 40 00  ‚Üí  reverse  ‚Üí  0x00401000  ‚Üê valid address range!
78 56 34 12  ‚Üí  reverse  ‚Üí  0x12345678  ‚Üê doesn't look like an address
            </pre>
            <p style="font-size: 0.9rem; color: var(--text-secondary);">
                Windows 32-bit addresses: usually in range <code>0x00400000</code> - <code>0x7FFFFFFF</code>
            </p>

            <div class="info-box">
                <div class="info-box-title">üí° Practical Tip</div>
                <p style="margin-bottom: 0;">
                    You don't always know 100% what the data type is - and that's okay! Look at the instructions that use it, follow where the value goes, and learn from context. That's part of the art of RE.
                </p>
            </div>

            <div class="warning-box">
                <div class="warning-box-title">üéØ The Simple Rule</div>
                <pre style="background: transparent; padding: 0; border: none; margin: 0;">
What you see in memory:    78 56 34 12
                              ‚Üì
Reverse the byte order:    0x12345678
                              ‚Üì
This is the value the CPU actually sees and works with!
                </pre>
                <p style="margin-bottom: 0; margin-top: 1rem;">
                    <strong>In short:</strong> Reversing bytes lets you "think like the CPU" - and that's exactly what we do in Reverse Engineering!
                </p>
            </div>

            <h2>üìã Chapter Summary</h2>
            
            <ul>
                <li><strong>x86</strong> = 32-bit, <strong>x64</strong> = 64-bit</li>
                <li><strong>General Purpose Registers:</strong> EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP</li>
                <li><strong>EIP/RIP</strong> = pointer to next instruction</li>
                <li><strong>FLAGS</strong> = flags indicating results (ZF, SF, CF, OF)</li>
                <li><strong>Little Endian</strong> = low byte stored first. Reverse bytes of numbers and addresses to see what the CPU sees!</li>
                <li><strong>Identify data type:</strong> Look at instruction (register size), operation type (call/jmp = address), and patterns (ASCII + null = string)</li>
                <li>Cycle: Fetch ‚Üí Decode ‚Üí Execute ‚Üí Repeat</li>
            </ul>

            <div class="nav-buttons">
                <a href="chapter2.html" class="nav-btn">‚Üê Chapter 2: Numbers</a>
                <a href="chapter4.html" class="nav-btn">Chapter 4: Memory Management ‚Üí</a>
            </div>
        </div>
    </div>
</body>
</html>
